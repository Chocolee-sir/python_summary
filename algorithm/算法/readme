算法（Algorithm）：一个计算过程，解决问题的方法
-------------------------------------------
复习递归：
递归的两个特点：
调用自身
结束条件
-------------------------------------------
时间复杂度：用来评估算法运行效率的一个东西
O(1)
O(n)
O(n²)
O(logn)

时间复杂度是用来估计算法运行时间的一个式子（单位）。
一般来说，时间复杂度高的算法比复杂度低的算法快。
常见的时间复杂度（按效率排序）
O(1)<O(logn)<O(n)<O(nlogn)<O(n2)<O(n2logn)<O(n3)
不常见的时间复杂度（看看就好）
O(n!) O(2n) O(nn) …

如何一眼判断时间复杂度？
循环减半的过程O(logn)
几次循环就是n的几次方的复杂度
-------------------------------------------
空间复杂度：用来评估算法内存占用大小的一个式子
-------------------------------------------
列表查找：从列表中查找指定元素
输入：列表、待查找元素
输出：元素下标或未查找到元素

顺序查找
从列表第一个元素开始，顺序进行搜索，直到找到为止。
二分查找
从有序列表的候选区data[0:n]开始，通过对待查找的值与候选区中间值的比较，可以使候选区减少一半。
-------------------------------------------
列表排序
将无序列表变为有序列表
应用场景：
各种榜单
各种表格
给二分查找用
给其他算法用

输入：无序列表
输出：有序列表

排序low B三人组：
冒泡排序
选择排序
插入排序
快速排序
排序NB二人组：
堆排序
归并排序
没什么人用的排序：
基数排序
希尔排序
桶排序

-------------------------------------------
冒泡排序思路：
首先，列表每两个相邻的数，如果前边的比后边的大，那么交换这两个数……

选择排序思路：
一趟遍历记录最小的数，放到第一个位置；
再一趟遍历记录剩余列表中最小的数，继续放置；

插入排序思路:
列表被分为有序区和无序区两个部分。最初有序区只有一个元素。
每次从无序区选择一个元素，插入到有序区的位置，直到无序区变空。

-------------------------------------------
快速排序：快
好写的排序算法里最快的
快的排序算法里最好写的

快排思路：
取一个元素p（第一个元素），使元素p归位；
列表被p分成两部分，左边都比p小，右边都比p大；
递归完成排序。

坏处：
极端最坏情况，如果是一个倒序的数据，会悲剧。
递归问题，python中深度需要设置。

-------------------------------------------
堆排序前传——树与二叉树简介
树是一种数据结构          比如：目录结构
树是一种可以递归定义的数据结构
树是由n个节点组成的集合：
如果n=0，那这是一棵空树；
如果n>0，那存在1个节点作为树的根节点，其他节点可以分为m个集合，每个集合本身又是一棵树。
一些概念
根节点、叶子节点
树的深度（高度）
树的度
孩子节点/父节点
子树

二叉树：度不超过2的树（节点最多有两个叉）
满二叉树
完全二叉树

二叉树的存储方式：
链式存储方式
顺序存储方式（列表）
父节点和左孩子节点的编号下标有什么关系？  i ~ 2i+1
0-1 1-3 2-5 3-7 4-9
父节点和右孩子节点的编号下标有什么关系？ i ~ 2i+2
0-2 1-4 2-6 3-8 4-10
比如，我们要找根节点左孩子的左孩子

二叉树是度不超过2的树
满二叉树与完全二叉树
（完全）二叉树可以用列表来存储，通过规律可以从父亲找到孩子或从孩子找到父亲

-------------------------------------------
堆排序
大根堆：一棵完全二叉树，满足任一节点都比其孩子节点大
小根堆：一棵完全二叉树，满足任一节点都比其孩子节点小

堆排序过程：
建立堆
得到堆顶元素，为最大元素
去掉堆顶，将堆最后一个元素放到堆顶，此时可通过一次调整重新使堆有序。
堆顶元素为第二大元素。
重复步骤3，直到堆变空。

-------------------------------------------
归并排序
假设现在的列表分两段有序，如何将其合成为一个有序列表

分解：将列表越分越小，直至分成一个元素。
一个元素是有序的。
合并：将两个有序列表归并，列表越来越大。

-------------------------------------------
快速排序、堆排序、归并排序-小结:
三种排序算法的时间复杂度都是O(nlogn)

一般情况下，就运行时间而言：
快速排序 < 归并排序 < 堆排序

三种排序算法的缺点：
快速排序：极端情况下排序效率低
归并排序：需要额外的内存开销
堆排序：在快的排序算法中相对较慢

-------------------------------------------
优先队列：一些元素的集合，POP操作每次执行都会从优先队列中弹出最大（或最小）的元素。
堆——优先队列










